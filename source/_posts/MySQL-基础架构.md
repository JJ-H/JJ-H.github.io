---
title: MySQL 基础架构
date: 2023-02-26 01:50:04
tags: MySQL
---
>  本文参照《高性能 MySQL》一书总结

Mysql 是可插拔的，其架构特点使其可以被应用在多种场景，足够灵活。为了最大限度地使用 MySQL，需要了解它的设计，以便用其所长，避其所短。

## MySQL 的逻辑架构

MySQL 采用的是分层设计思想

1、第一层：连接层

该层所包含的服务并不是 MySQL 特有的，绝大多数基于网络的客户端/服务器工具都有类似的服务，主要是包括如：连接处理、身份校验、确保安全等。

2、第二层：服务层

该层主要负责MySQL的核心功能，它接收从客户端输入的 SQL 语句，并对其进行解析、分析、优化等操作，MySQL 中一些内置的函数、跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等

3、第三层：存储引擎层

g存储引擎负责 MySQL 中数据的存储和提取。存储引擎有多种，每种引擎都有适合其使用的场景，具体可查看MySQL不同存储引擎的对比，由于服务器是通过存储引擎的 API 来进行交互，这些 API 屏蔽了底层存储引擎的差异，使得它们对上面的查询层基本是透明的。存储引擎还包含几十个底层函数，用于执行如“开始一个事物"、“根据主键提取某一行数据"等操作，但是存储引擎不会解析 SQL，不同存储引擎之间也不会有通讯，只是简单的响应服务器的请求。

## 连接管理与安全性

默认情况下，每个客户端连接都会在服务器进程中拥有一个线程，该连接的查询只会在这个单独的线程中执行，该线程驻留一个内核或者 CPU 上。服务器维护了一个缓存区域，用于存放已就绪的线程（线程池），硬刺不需要为每个新的连接创建或者销毁线程。

## 优化与执行

MySQL 解析查询以创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择合适的索引等等。但用户也可以通过关键字向优化器传递提示，从而影响优化器的决策过程。当然，你也可以请求服务器解释优化过程的各个方面，使用户可以知道服务器是如何进行优化决策的，提供一个参考点，便于用户重构查询或 schema、修改相关配置等。

> 从 MySQL 5.7.20 版本开始，查询缓存已经被官方标志为弃用的特性，并在 8.0 版本中完全被移除。缓存频繁查询的语句可以使用 memcached 或者 Redis

## 并发控制

无论何时，只要有多个查询需要同时修改数据，就会产生并发控制的问题。怎样确保临界资源的安全性，下面我们介绍一些“手段"———锁

### 读写锁

处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统。这两种锁通常被称为 **共享锁（shared lock）** 和 **排他锁（exclusive lock）**，也称为 **读锁**、**写锁**

锁的概念可以如下描述：资源上的读锁是共享的，或者说是相互不阻塞的。多个客户端可以同时读取同一个资源而互不干扰。写锁则是排他的，也就是说，一个写锁即会阻塞读锁，也会阻塞其他的写锁，这是处于安全考虑，确保临界资源在特定的时间点只能被一个客户端修改成功。

### 锁粒度

一种提高共享资源并发的方式就是让锁定对象更有选择性，尽量只锁定包含需要修改的部分数据，而不是所有资源。更理想的方式是，只对需要的修改的数据片段进行精确的锁定（片段锁）。任何时候，让锁定的数据量最小化，理论上就能保证在给定资源上进行更改操作的并发数更高。

但问题来了，加锁也是要消耗资源的。锁的各种操作，包括获取锁、检查锁是否空闲、释放锁等等，都会增加系统开销。如果系统花费大量的时间来管理锁，而不是取数据，那么系统的性能可能会受影响。

> 锁策略是在锁开销和数据安全之间的平衡，这种平衡会影响性能

MySQL 提供了多种锁的选择。每种存储引擎都可以实现自己的锁策略和锁粒度，在设计存储引擎时，锁的管理是一个非常重要的决定。将锁粒度固定在某个级别，可以提高某些场景下的性能，但同时会使其不适合另外一些场景。

#### 表锁

表锁（table lock）是 MySQL 中最基本也是开销最小的锁策略。他会锁定整张表。当客户端想对表进行写操作（插入、删除、更新等），需要先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。只有没人执行写操作时，其他读取的客户端才能获得锁，读锁止键不会相互阻塞。

#### 行锁

使用行锁（row lock）可以最大程度地支持并发处理（也带来了最大的锁开销）。这种策略允许用户同时操作不同的行，而不会彼此阻塞
